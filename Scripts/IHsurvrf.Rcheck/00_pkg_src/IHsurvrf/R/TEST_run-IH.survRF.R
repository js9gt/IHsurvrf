#
#
#set.seed(123)
#source("R/SCRATCH_VerifyModels.R")
#source("R/class_IH.Parameters.R")
#source("R/IH.survRF.R")
#source("R/IH.predictSurvTree.R")
##
#
###
#library(survival)
#library(IHsurvrf)
#dyn.load("src/IHsurvrf.so")
##
##
##
### simulate data for a single stage: "1"
#dt <- data.frame("Y" = sample(1:400,100,TRUE),
#                  "D" = rbinom(100, 1, 0.7),
#                  "A" = rbinom(100, 1, 0.5),
#                  "X" = rnorm(100),
#                 # Z is a categorical variable
#                  "Z" = as.factor(sample(1:5, 100, TRUE)))
##
##
##
### defined in VerifyTxName.R Script
## txName = A.1 (binary treatment 0 or 1)
## character
##
#txName <- "A"
##
##
### create model
####### NOTE: use Verifymodels.R
#models <-Surv(Y,D)~X+A+Z
##
##
#nDP <- 1
##
### defined in VerifyUsePrevTime.R script
##
#usePrevTime <- F
##
#stageLabel <- "."
##
## ensure that 'models' is provided as a formula or a list of formula and
## that the provided models can be generated by the data. If the input is
## appropriate, the object returned is list containing
##   "models" - the original input.
##   "response" - matrix of the survival response variables
##
### used in script VerifyModels.R
##
#models <- .VerifyModels(models = models,
#                        nDP = nDP,
#                        data = dt,
#                        txName = txName,
#                        stageLabel = stageLabel,
#                        usePrevTime = usePrevTime)
##
##
### extracts the "response variable": matrix of survival response variables
#response <- models$response
##
### extracts the "delta" variable
#del <- models$delta
##
### only including the models themselves & discarding "response" and "delta" components
#models <- models$models
##
### create params
##
#params <- .parameters(timePoints = "exp",
#                      tau = NULL,
#                      nTimes = 100L,
#                      response = response,
#                      nTree = 10L,
#                      ERT = TRUE,
#                      uniformSplit = NULL,
#                      randomSplit = 0.2,
#                      splitRule = NULL,
#                      replace = NULL,
#                      nodeSize = 2L,
#                      minEvent = 2L,
#                      tieMethod = "random",
#                      criticalValue = "surv.prob",
#                      survivalTime = NULL,
#                      nSamples = nSamples,
#                      pooled = FALSE,
#                      stratifiedSplit = NULL)
#
#crit <- .CriticalValueCriterion(params)
#
#crit <- .CriticalValueCriterion(params)
#if (crit == "mean") {
#
#  ## set index to 0 (integer)
#  ind = 0L
#
#  ## set fraction to 0.0
#  frac = 0.0
#
#  ## meaning, for mean-based criteria, specific index and fraction aren't applicable or needed
#
#} else if (crit == "surv.mean" || crit == "surv.prob") {
#
#  ## retrieve the "Index" and the"sFraction" from the params object
#  ## these are output depending on the input "survivalTime" parameter
#  ind = params@sIndex
#  frac = params@sFraction
#}
#
#
##
### ignoring prior step
##
### prepares model frame using the formula (input) and the data (input)
### missing values are not specifically handled (not omitted)
##
#x <- stats::model.frame(formula = models, data = dt, na.action = na.pass)
##
## identify individuals with complete data
#elig <- stats::complete.cases(x)
##
## extract response and delta from model frame
##
### extract survival response
#response <- stats::model.response(data = x)
##
### extract censoring indicator (delta) from the second column of the "response" data
### "L" is used to indicate that 2 is an integer
#delta <- response[,2L]
##
### updates the "response" variable to only include the first column of the original "response" data which represents survival times
#response <- response[,1L]
##
### if first column of the model frame (x) is the response variable, remove this column
### probablhy to construct predicte response from the predictors, since the response has nothing to do with the prediction itself
#if (attr(x = terms(x = models), which = "response") == 1L) {
#  x <- x[,-1L,drop = FALSE]
#}
##
##
## identify time points <= response
#tSurv <- sapply(X = response[elig],
##
#                # results in a logical integer (0 = FALSE)
#                FUN = function(s, tp) { as.integer(x = {s < tp}) },
#                tp = .TimePoints(object = params))
##
## time point nearest the response without going over
## {nTimes x nElig}
##
### pr: probability mass vector which binds transformed survival times (1, 0) (excluding first row) w values with a row of 1s
### for tSurv,each element is 1 if the survival time < corresponding time point. Otherwise, it's 0
### then subtract the transformed survival times to create a probability mass vector
### this calculates the difference between successive elements in each row of tSurv by translating binary indicators into p.survival until each time point
### there's now mass 1 at time point where each survival time is censored or an event, and 0 for all other time points
##
#pr <- {rbind(tSurv[-1L,],1)-tSurv}
##
##
### extract levels of the factor treatment variable for eligible cases
#txLevels <- levels(x = factor(x = dt[elig,txName]))
##
##
##
### running code:
#
#
#result <- .survRF(
##
#  ## selects subset of predictor matrix for eligible cases & ensures result is a matrix
#  x = x[elig,,drop=FALSE],
#  y = response[elig],
#  pr = pr,
#  delta = delta[elig],
#  params = params,
#  mTry = 5L,
#  txLevels = txLevels,
#  model = models,
#  sampleSize = 0.3)
#
#
########## testing .predictSurvTree
#
#newdata = dt[elig,]
#
#
### extract levels of all factors in "newdata" to make sure the categorical variables match those used for model training
#xLevels <- lapply(X = newdata, FUN = levels)
#
#object = result
#
### iterate over each variable
#
#for (i in length(x = xLevels)) {
#
#  ## if both the newdata level for ith variable and model level for ith variable are null, skip current iteration
#
#  if (is.null(x = xLevels[[ i ]]) &&
#      is.null(x = object@xLevels[[ i ]])) next
#
#  ## if data introduces new factor levels not in model, stop execution and present error message
#
#  if (any(! {xLevels[[ i ]] %in% object@xLevels[[ i ]]})) {
#    stop("new factor levels not present in the training data",
#         call. = FALSE)
#  }
#}
#
## verify that type of data is the same as the training data
## type means numeric (nCat = 0), ordered factor (nCat = 1), or
## factor (nCat = length(levels(x)))
#
### determines number of categories for each variable in newdata
#
#nCat <- sapply(X = xLevels, FUN = length)
#
### if ncat is ordered factors, adjust this value to 1
#
#nCat <- ifelse(test = sapply(X = newdata, FUN = is.ordered),
#               yes = 1L,
#               no = nCat)
#
### if the datatypes in model don't match the data types in nCat,
## object@nCat is from the input survRF object
#
#if (any(unlist(x = object@nCat) != unlist(x = nCat))) {
#
#  ## stop running and output warning message
#
#  stop("type of predictors in newdata do not match the training data",
#       call. = FALSE)
#}
#
### retrieves number of trees in the forest from the input survRF object
#
#nTree <- length(x = object@trees)
#
#pred <- .predictSurvTree(x = newdata,
#                 params = params,
#                 nCat = nCat,
#
#                 ## this is how you know the prediction is for the first tree
#                 ## the trees slot contains a list of all the trees in the forest
#
#
#                 nodes = object@trees[[ 1L ]])
#
