
# Verify input 'models'
#
# method is not exported and is for internal convenience only
#
# ensures that 'models' is provided as a formula or a list of formula,
# that the provided models can be generated by the data, and extracts the
# survival response variable.
#
# successful methods return a list containing the formula(s) and
# the survival response variable(s)
#


## create a new generic function called .VerifyModels
## used in IH.dtrSurv.R

setGeneric(name = ".VerifyModels",
           def = function(models, ...) { standardGeneric(".VerifyModels") })

#-------------------------------------------------------------------------------
# the default method generates an error
#-------------------------------------------------------------------------------

## return an error when used on non-specific classes
setMethod(f = ".VerifyModels",
          signature = c(models = "ANY"),
          definition = function(models, ...) {
            stop("models must be a formula object or a list of formula objects")
          })

#-------------------------------------------------------------------------------
# method returns a list containing "models", the models for each decision,
# "response", the survival response as a single column matrix, and
# "delta", the event status as a single column matrix
#-------------------------------------------------------------------------------

## define a new method used on objects of class "formula"

setMethod(f = ".VerifyModels",
          signature = c(models = "formula"),
          definition = function(models, ...,
                                nDP,
                                data,
                                txName,
                                stageLabel) {

            ## create a modelframe fom the input "models" and "data"

            # ensure that model frame can be generated from provided data

            ## tries to execute code in "expr" argument-- if this fails, "tryCatch" catches this & does user-defined function
            mf <- tryCatch(expr = model.frame(formula = models,
                                              data = data,

                                              ## NA values are left as-is in the resulting model frame
                                              na.action = na.pass),

                           ## if this fails due to incompatible data, generate an error message and return NULL

                           error = function(e){
                             message("unable to create model frame for model ",
                                     deparse(expr = models), "\n", e$message)
                             return( NULL )
                           })


            if (is.null(x = mf) && nDP > 1L) {

              ## use a common formula approach by recursively calling .VerifyModels with the new models
              ## handles scenarios where a single formula applies to multiple decision points

              # assume that a failure indicates a common formula: applies commonFormula approach
              ## commonFormula function specified later in this script

              models <- commonFormula(models = models,
                                      nDP = nDP,
                                      data = data,
                                      txName = txName,
                                      stageLabel = stageLabel)

              # call method for list of models after applying commonFormula approach
              ## this method is coded below for objects of class "list"
              return( .VerifyModels(models = models,
                                    nDP = nDP,
                                    data = data,
                                    txName = txName) )

            }



            ## if the number of decision points not 1

            # formula objects can only be provided for single decision point
            # or for common formula
            if (nDP != 1L) {

              ## stop running and output an error

              stop("insufficient number of models provided", call. = FALSE)
            }

            ## try to create another model frame

            ## after editing the initial model formula and data (through the scenarios described above, try creating model frame again)

            # ensure that model frame can be generated from provided data
            mf <- tryCatch(expr = model.frame(formula = models,
                                              data = data,
                                              na.action = na.pass),
                           error = function(e){
                             stop("unable to create model frame for model ",
                                  deparse(expr = models), "\n", e$message,
                                  call. = FALSE)
                           })

            ## ensures the first column of the model frame (which is survival time) is of class "Surv". If not,


            if (!is(object = mf[,1], class2 = "Surv")) {

              ## stop running code, and output an error message

              stop("models must be survival models; use Surv()",
                   call. = FALSE)
            }

            ## extract survival response from the model frame, format as a single column matrix

            # extract survival response
            resp <- matrix(data = model.response(data = mf)[,1L], ncol = 1L)

            ## extract event status from the model frame, format as a single column matrix

            # extract event
            del <- matrix(data = model.response(data = mf)[,2L], ncol = 1L)

            ## return a list with the original models, survival response, and delta

            return( list("models" = models, "response" = resp, "delta" = del) )
          })


#-------------------------------------------------------------------------------
# Helper function for commonFormula to remove labels
#-------------------------------------------------------------------------------

# internal function identifies element of dataNames that include the provided
# label and removes all instances of that label from the dataNames object
rmCov <- function(

  ## vector of names (strings)
  dataNames,
  ## specific label (string) to be removed
  label,
  ## label used to mark different stages
  stageLabel, nDP) {

  # split remaining data names at stageLabel
  # a list is created, each element contains 1 or more elements
  # the first is the covariate name before stageLabel
  # the second, if present, is the first component after the
  # first stageLabel
  # the third, if present, means that there are multiple stageLabels
  #   in the covariate name -- this is no longer allowed

  ## split each name in dataNames at occurrences of "stageLabel" to get a list called "cpv"
  cov <- strsplit(x = dataNames, split = stageLabel, fixed = TRUE)

  ## checks if any name in "dataNames" containsmore than one instance of "stageLabel"

  tst <- sapply(X = cov, FUN = length) > 2L

  ## if so, outputs an error message

  if (any(tst)) {
    stop("data headers cannot contain multiple instances of the stage label",
         call. = FALSE)
  }

  ## identifies which names start with the specified label. Check if the first segment matches "label"
  ## outputs a logical vector where it's TRUE  whether each name in dataNames matches the label

  # identify the label
  areLabel <- sapply(X = cov, FUN = function(x){x[1L] == label})


  ## if the number of names matching "label" is smaller than the number of decision points, stops execution with an error
  if (sum(areLabel) < nDP) {
    stop("insufficient number of ", label, "variables in data",
         call. = FALSE)
  }

  ## updates "dataNames" by removing the names matching the label

  # remove label's from dataNames
  dataNames <- dataNames[!areLabel]

  return( dataNames )
}


## EXAMPLE:

## Example data names
#dataNames <- c("Y_1", "Y_2", "Y_3", "Y_4", "X_1", "X_2", "X_3", "X_4", "Z_1", "Z_2", "Z_3", "Z_4")
#
## Parameters
#label <- "Y"          # Label to be removed
#stageLabel <- "_"      # Stage label
#nDP <- 4               # Number of decision points
#
## Call the rmCov function, removes the label of the name entirely,so now we don't see any Y's at all
#updatedDataNames <- rmCov(dataNames, label, stageLabel, nDP)
#

#-------------------------------------------------------------------------------
# Function for commonFormula using previous times
#-------------------------------------------------------------------------------


## used above in .VerifyModels function

## constructs a common formula for survival models based on input parameters, accounting for multiple decision points
## manipulates variable names to construct a formula that can be applied across dif stages/points in a dataset
commonFormula <- function(models, ...,
                          nDP,
                          data,
                          txName,
                          stageLabel) {

  ## outputs a message saying the function assumes common formula across all time points

  message("assuming a common formula")

  ## extract survival time (yLabel) and delta (dLabel) names form the LHS of the formula
  ## assumes a specific structure where the 2nd and third elements after ~ represent survival time and event indicator
  ## Surv(time,event) ~ covariates

  # extract y and delta labels from lhs of formula
  yLabel <- deparse(expr = models[[ 2L ]][[ 2L ]])
  dLabel <- deparse(expr = models[[ 2L ]][[ 3L ]])

  ## create LHS of the model for each decision point
  ## combines survival and event indicator variables with each decision point identifier using "stageLabel" to denote dif decision points


  # create lhs of models
  resp <- paste0("Surv(", yLabel, stageLabel, 1L:nDP, ",",
                 dLabel, stageLabel, 1L:nDP, ")~")

  ## retrieve the names of the covariates from the RHS of the formula

  # extract covariate labels from rhs of formula
  xLabels <- attr(x = terms(x = models), which = "term.labels")


  # extract tx variable label from txName vector

  ## split the treatment variable names by "stageLabel"
  txLabel <- strsplit(x = txName, split = stageLabel, fixed = TRUE)

  ## after splitting, iterate over the list of split names; for each treatment name, extract first component
  ## assumes first component is common label identifying treatment across dif stages/time points
  txLabel <- sapply(X = txLabel, function(x){ x[1L] })

  ## checks if all the extracted labels from the first component are the same
  ## if not all the labels match, halt execution with an error message
  ## ensures all treatment variables share a common base name in the model

  if (!all(txLabel %in% txLabel[1L])) {
    stop("tx names do not have a common label", call. = FALSE)
  }

  ## simplify "txLabel" to be the first element
  txLabel <- txLabel[1L]

  ## count how many times the treatment label appears in "xLabels" which contains covariate names from the RHS of formula
  ## determines whether (& how many times) treatment variable is used as a covariate in the model

  # check to see if  treatment is in formula
  txInXLabels <- sum(xLabels %in% txLabel)

  ## if the treatment label appears more than once,it's a problem

  # if more than 1 label in xLabels matches treatment, there is a problem
  if (txInXLabels > 1L) {
    stop("unable to interpret model", call. = FALSE)
  }

  ## if the treatment variable is identified exactly once in the covar names, it's removed from "xLabels"
  ## prevents double counting of the treatment variables as a covariate as well as a separate entity

  # if tx variable in model, remove from covariate label vector
  if (txInXLabels == 1L) {
    xLabels <- xLabels[!(xLabels %in% txLabel)]
  }

  ## extract column names in the data to identify available variables

  # extract headers from data
  dataNames <- colnames(x = data)

  # remove txNames from dataNames

  ## rmCov function defined above in this script
  dataNames <- rmCov(dataNames = dataNames,
                     label = txLabel,
                     stageLabel = stageLabel,
                     nDP = nDP)

  # remove response from dataNames
  ## using rmCov (defined above), remove response names

  ## rmCov function defined above in this script
  dataNames <- rmCov(dataNames = dataNames,
                     label = yLabel,
                     stageLabel = stageLabel,
                     nDP = nDP)

  # remove event indicators from dataNames
  ## using rmCov (defined above), remove delta

  ## rmCov function defined above in this script
  dataNames <- rmCov(dataNames = dataNames,
                     label = dLabel,
                     stageLabel = stageLabel,
                     nDP = nDP)

  ## prepare RHS of the model by adding treatment back in if it was initially part of the formula

  # dataNames now only contains covariate names

  ## checks of treatment label has been identified in the covariate labels (present once or more in the labels)

  # if tx label in formula, add back dp component and include in
  # rhs of models
  if (txInXLabels) {

    ## if so, construct a list where each element is a modified version of the treatment variable name for each decision point
    ## the "paste0" part creates new variable names by adding the "stageLabel" and decision point

    mod <- as.list(x = paste0(txLabel, stageLabel, 1L:nDP))
  } else {

    ## otherwise, if the treatment lavel isn't found, this initializees a list as an empty placeholder
    mod <- vector(mode = "list", length = nDP)
  }

  ## if there are any covariate labels "xLabels" (AKA not empty), there are covars that need to be processed

  # if non-tx covariates in rhs, extract, add decision point if appropriate
  # and add to rhs
  if (length(x = xLabels) > 0L) {

    ## split each of the names in "dataNames" by the stage label

    # split remaining data names at stageLabel
    cov <- strsplit(x = dataNames, split = stageLabel, fixed = TRUE)

    ## extract the first component from each element of the split dataNames
    ## this is the base covariate name

    # extract label component
    covLabels <- sapply(X = cov, FUN = function(x){x[1L]})

    ## then, determine which of the extracted label components are included in the model's covariate labels

    # identify which covLabels are in model
    covInModel <- covLabels %in% xLabels

    ## checks if the number of covariates identified as relevant for the model exceeds the number of unique covariate labels in xLabels
    ## this would mean some covariates are associated with specific decision points instead of being baseline (x1,x2,x3)

    # if data is (X1, X2, X3) as baseline covariates xLabels will be
    # ("X1","X2","X3")
    # if data is (X.1, X.2, X.3) as dp covariates, xLabels will be "X"
    if (sum(covInModel) > length(x = xLabels)) {

      ## loop through each decision point

      # implies that there are decision point values concatenated
      for (i in 1L:nDP) {

        ## construct decision point-specific covariate names by adding the stageLabel and decision point to each covariate label
        stageCovs <- paste0(xLabels, stageLabel, i)
        # this allows for covariates that are not defined in other stages

        ## then check which of the constructed covariate names exist in "dataNames"
        useCovs <- stageCovs %in% dataNames

        ## if they exist, update the model component list for each decision point with these covariates
        mod[[ i ]] <- c(mod[[ i ]], stageCovs[useCovs])
      }

      ## otherwise, if the number of covariates doesn't exceed the lnegth of the labels, the covariates are baseline

    } else {

      ## loop through each of the decision points

      # implies that covariates are baseline
      for (i in 1L:nDP) {

        ## each decision point's model component list is update to include all covariates without modification
        mod[[ i ]] <- c(mod[[ i ]], xLabels)
      }
    }
  }


  message("models identified as ")

  ## construct the final model formula for each decision point by combining the LHS constructured with the RHS for each decision point
  ## outputs messages showing constructed formulas

  ## initialize an empty list named "mods" to store the model formulas for each decision point
  mods <- list()

  ## loop through each decision point from the first to the last
  ## purpose: to construct and store a model formula for each decision point based on previous components
  for (i in 1L:nDP) {

    ## print the constructed formula for the ith decision point which combines the response variable with RHS of formula
    ## construct a string representation of the model, separated by + signs
    message("\t", paste0(resp[i], paste(mod[[ i ]], collapse="+")))

    ## construct a string representation of the formula by concatenanting response side with predictors and terms
    mods[[ i ]] <- stats::as.formula(paste0(resp[i],
                                            paste(mod[[ i ]], collapse="+")))

  }

  ## returns list of formula objects ("mods"), each representing the model for a decision point

  return( mods )

}


#-------------------------------------------------------------------------------
# method to ensure that the number of models provided is appropriate, that
# each model can be generated from the provided data, and to extract the
# survival response variables.
#-------------------------------------------------------------------------------
# method returns a list containing "models", the unaltered model,
# "response", the survival response as a nDP column matrix, and
# "delta", the event status as a nDP column matrix
#-------------------------------------------------------------------------------

## define a new function that operates when the models in put is of class "list"

setMethod(f = ".VerifyModels",
          signature = c(models = "list"),
          definition = function(models, ..., nDP, data) {

            ## ensures number of models provided matches the number of decision points

            # a model must be provided for each decision point
            if (length(x = models) != nDP) {

              ## otherwise, stops execution with a returned error message

              stop("insufficient number of models", call. = FALSE)
            }

            # ensure that each element of the list is a formula and extract
            # the response variable

            ## initialize empty vaiables to store extracted survival response and event indicator
            resp <- NULL
            del <- NULL

            ## loop through each of the decision points
            for (i in 1L:nDP) {

              ## each model is a formula, so we use the .VerifyModel on a formula class like earlier
              ## method returns a list containing "models", the models for each decision,
              # "response", the survival response as a single column matrix, and
              # "delta", the event status as a single column matrix
              tst <- .VerifyModels(models = models[[ i ]],

                                   ## for each model, set number of decision points to 1
                                   nDP = 1L,
                                   data = data)

              ## updates the model list with the verified formulas
              models[[ i ]] <- tst$models

              ## extracts aggregate response and event indicator across all decision points
              resp <- cbind(resp, tst$resp)
              del <- cbind(del, tst$del)
            }

            ## return a list containing processed and verified model formulas

            return( list("models" = models, "response" = resp, "delta" = del) )
          })
