## to load the fortran code
library(IHsurvrf)
library(methods)
## to use "Surv" for model
library(survival)
## simulate data for a single stage: "1"
dt <- data.frame("Y" = sample(1:100,100,TRUE),
"D" = rbinom(100, 1, 0.9),
"A" = rbinom(100, 1, 0.5),
"X" = rnorm(100))
## defined in VerifyTxName.R Script
# txName = A.1 (binary treatment 0 or 1)
# character
txName <- "A"
## create model
###### NOTE: use Verifymodels.R
models <-Surv(Y,D)~X+A
nDP <- 1
## defined in VerifyUsePrevTime.R script
usePrevTime <- F
stageLabel <- "."
# ensure that 'models' is provided as a formula or a list of formula and
# that the provided models can be generated by the data. If the input is
# appropriate, the object returned is list containing
#   "models" - the original input.
#   "response" - matrix of the survival response variables
## used in script VerifyModels.R
models <- .VerifyModels(models = models,
nDP = nDP,
data = dt,
txName = txName,
stageLabel = stageLabel,
usePrevTime = usePrevTime)
## extracts the "response variable": matrix of survival response variables
response <- models$response
## extracts the "delta" variable
del <- models$delta
## only including the models themselves & discarding "response" and "delta" components
models <- models$models
## create params
params <- .parameters(timePoints = "quad",
tau = NULL,
nTimes = 100L,
response = response,
nTree = 10L,
ERT = TRUE,
uniformSplit = NULL,
randomSplit = 0.2,
splitRule = NULL,
replace = NULL,
nodeSize = 6L,
minEvent = 3L,
tieMethod = "random",
criticalValue = "mean",
survivalTime = NULL,
nSamples = nSamples,
pooled = FALSE,
stratifiedSplit = NULL)
## ignoring prior step
## prepares model frame using the formula (input) and the data (input)
## missing values are not specifically handled (not omitted)
x <- stats::model.frame(formula = models, data = dt, na.action = na.pass)
# identify individuals with complete data
elig <- stats::complete.cases(x)
# extract response and delta from model frame
## extract survival response
response <- stats::model.response(data = x)
## extract censoring indicator (delta) from the second column of the "response" data
## "L" is used to indicate that 2 is an integer
delta <- response[,2L]
## updates the "response" variable to only include the first column of the original "response" data which represents survival times
response <- response[,1L]
## if first column of the model frame (x) is the response variable, remove this column
## probablhy to construct predicte response from the predictors, since the response has nothing to do with the prediction itself
if (attr(x = terms(x = models), which = "response") == 1L) {
x <- x[,-1L,drop = FALSE]
}
# identify time points <= response
tSurv <- sapply(X = response[elig],
# results in a logical integer (0 = FALSE)
FUN = function(s, tp) { as.integer(x = {s < tp}) },
tp = .TimePoints(object = params))
pr <- {rbind(tSurv[-1L,],1)-tSurv}
## extract levels of the factor treatment variable for eligible cases
txLevels <- levels(x = factor(x = dt[elig,txName]))
result <- .survRF(
## selects subset of predictor matrix for eligible cases & ensures result is a matrix
x = x[elig,,drop=FALSE],
y = response[elig],
pr = pr,
delta = delta[elig],
params = params,
mTry = 5L,
txLevels = txLevels,
model = models,
sampleSize = 0.2)
library(IHsurvrf)
result <- .survRF(
## selects subset of predictor matrix for eligible cases & ensures result is a matrix
x = x[elig,,drop=FALSE],
y = response[elig],
pr = pr,
delta = delta[elig],
params = params,
mTry = 5L,
txLevels = txLevels,
model = models,
sampleSize = 0.2)
library(IHsurvrf)
result <- .survRF(
## selects subset of predictor matrix for eligible cases & ensures result is a matrix
x = x[elig,,drop=FALSE],
y = response[elig],
pr = pr,
delta = delta[elig],
params = params,
mTry = 5L,
txLevels = txLevels,
model = models,
sampleSize = 0.2)
dyn.load("/src/IHsurvrf.so")
dyn.load("src/IHsurvrf.so")
result <- .survRF(
## selects subset of predictor matrix for eligible cases & ensures result is a matrix
x = x[elig,,drop=FALSE],
y = response[elig],
pr = pr,
delta = delta[elig],
params = params,
mTry = 5L,
txLevels = txLevels,
model = models,
sampleSize = 0.2)
source("IH.survRF.R")
dyn.load("src/IHsurvrf.so")
result <- .survRF(
## selects subset of predictor matrix for eligible cases & ensures result is a matrix
x = x[elig,,drop=FALSE],
y = response[elig],
pr = pr,
delta = delta[elig],
params = params,
mTry = 5L,
txLevels = txLevels,
model = models,
sampleSize = 0.2)
source("SCRATCH_VerifyModels.R")
source("class_IH.Parameters.R")
source("IH.survRF.R")
#library(IHsurvrf)
dyn.load("src/IHsurvrf.so")
library(methods)
## to use "Surv" for model
library(survival)
## simulate data for a single stage: "1"
dt <- data.frame("Y" = sample(1:100,100,TRUE),
"D" = rbinom(100, 1, 0.9),
"A" = rbinom(100, 1, 0.5),
"X" = rnorm(100))
## defined in VerifyTxName.R Script
# txName = A.1 (binary treatment 0 or 1)
# character
txName <- "A"
## create model
###### NOTE: use Verifymodels.R
models <-Surv(Y,D)~X+A
nDP <- 1
## defined in VerifyUsePrevTime.R script
usePrevTime <- F
stageLabel <- "."
# ensure that 'models' is provided as a formula or a list of formula and
# that the provided models can be generated by the data. If the input is
# appropriate, the object returned is list containing
#   "models" - the original input.
#   "response" - matrix of the survival response variables
## used in script VerifyModels.R
models <- .VerifyModels(models = models,
nDP = nDP,
data = dt,
txName = txName,
stageLabel = stageLabel,
usePrevTime = usePrevTime)
## extracts the "response variable": matrix of survival response variables
response <- models$response
## extracts the "delta" variable
del <- models$delta
## only including the models themselves & discarding "response" and "delta" components
models <- models$models
## create params
params <- .parameters(timePoints = "quad",
tau = NULL,
nTimes = 100L,
response = response,
nTree = 10L,
ERT = TRUE,
uniformSplit = NULL,
randomSplit = 0.2,
splitRule = NULL,
replace = NULL,
nodeSize = 6L,
minEvent = 3L,
tieMethod = "random",
criticalValue = "mean",
survivalTime = NULL,
nSamples = nSamples,
pooled = FALSE,
stratifiedSplit = NULL)
## ignoring prior step
## prepares model frame using the formula (input) and the data (input)
## missing values are not specifically handled (not omitted)
x <- stats::model.frame(formula = models, data = dt, na.action = na.pass)
# identify individuals with complete data
elig <- stats::complete.cases(x)
# extract response and delta from model frame
## extract survival response
response <- stats::model.response(data = x)
## extract censoring indicator (delta) from the second column of the "response" data
## "L" is used to indicate that 2 is an integer
delta <- response[,2L]
## updates the "response" variable to only include the first column of the original "response" data which represents survival times
response <- response[,1L]
## if first column of the model frame (x) is the response variable, remove this column
## probablhy to construct predicte response from the predictors, since the response has nothing to do with the prediction itself
if (attr(x = terms(x = models), which = "response") == 1L) {
x <- x[,-1L,drop = FALSE]
}
# identify time points <= response
tSurv <- sapply(X = response[elig],
# results in a logical integer (0 = FALSE)
FUN = function(s, tp) { as.integer(x = {s < tp}) },
tp = .TimePoints(object = params))
# time point nearest the response without going over
# {nTimes x nElig}
## pr: probability mass vector which binds transformed survival times (1, 0) (excluding first row) w values with a row of 1s
## for tSurv,each element is 1 if the survival time < corresponding time point. Otherwise, it's 0
## then subtract the transformed survival times to create a probability mass vector
## this calculates the difference between successive elements in each row of tSurv by translating binary indicators into p.survival until each time point
## there's now mass 1 at time point where each survival time is censored or an event, and 0 for all other time points
pr <- {rbind(tSurv[-1L,],1)-tSurv}
## extract levels of the factor treatment variable for eligible cases
txLevels <- levels(x = factor(x = dt[elig,txName]))
result <- .survRF(
## selects subset of predictor matrix for eligible cases & ensures result is a matrix
x = x[elig,,drop=FALSE],
y = response[elig],
pr = pr,
delta = delta[elig],
params = params,
mTry = 5L,
txLevels = txLevels,
model = models,
sampleSize = 0.2)
result <- .survRF(
## selects subset of predictor matrix for eligible cases & ensures result is a matrix
x = x[elig,,drop=FALSE],
y = response[elig],
pr = pr,
delta = delta[elig],
params = params,
mTry = 5L,
txLevels = txLevels,
model = models,
sampleSize = 0.2)
#library(IHsurvrf)
dyn.load("src/IHsurvrf.so")
result <- .survRF(
## selects subset of predictor matrix for eligible cases & ensures result is a matrix
x = x[elig,,drop=FALSE],
y = response[elig],
pr = pr,
delta = delta[elig],
params = params,
mTry = 5L,
txLevels = txLevels,
model = models,
sampleSize = 0.2)
result <- .survRF(
## selects subset of predictor matrix for eligible cases & ensures result is a matrix
x = x[elig,,drop=FALSE],
y = response[elig],
pr = pr,
delta = delta[elig],
params = params,
mTry = 5L,
txLevels = txLevels,
model = models,
sampleSize = 0.2)
#library(IHsurvrf)
dyn.load("src/IHsurvrf.so")
result <- .survRF(
## selects subset of predictor matrix for eligible cases & ensures result is a matrix
x = x[elig,,drop=FALSE],
y = response[elig],
pr = pr,
delta = delta[elig],
params = params,
mTry = 5L,
txLevels = txLevels,
model = models,
sampleSize = 0.2)
library(IHsurvrf)
dyn.load("src/IHsurvrf.so")
result <- .survRF(
## selects subset of predictor matrix for eligible cases & ensures result is a matrix
x = x[elig,,drop=FALSE],
y = response[elig],
pr = pr,
delta = delta[elig],
params = params,
mTry = 5L,
txLevels = txLevels,
model = models,
sampleSize = 0.2)
dyn.load("src/IHsurvrf.so")
result <- .survRF(
## selects subset of predictor matrix for eligible cases & ensures result is a matrix
x = x[elig,,drop=FALSE],
y = response[elig],
pr = pr,
delta = delta[elig],
params = params,
mTry = 5L,
txLevels = txLevels,
model = models,
sampleSize = 0.2)
dyn.load("src/IHsurvrf.so")
result <- .survRF(
## selects subset of predictor matrix for eligible cases & ensures result is a matrix
x = x[elig,,drop=FALSE],
y = response[elig],
pr = pr,
delta = delta[elig],
params = params,
mTry = 5L,
txLevels = txLevels,
model = models,
sampleSize = 0.2)
sessionInfo()
? IHsurvrf
ls("package:IHsurvrf")
library(IHsurvrf)
ls("package:IHsurvrf")
lsf.str("package:IHsurvrf")
devtools::build()
devtools::build()
devtools::check()
library(IHsurvrf)
ls("package:IHsurvrf")
lsf.str("package:IHsurvrf")
result <- .survRF(
## selects subset of predictor matrix for eligible cases & ensures result is a matrix
x = x[elig,,drop=FALSE],
y = response[elig],
pr = pr,
delta = delta[elig],
params = params,
mTry = 5L,
txLevels = txLevels,
model = models,
sampleSize = 0.2)
detach("package:IHsurvrf", unload = TRUE)
remove.packages("IHsurvrf")
unlink("IHsurvrf", recursive = TRUE)
file.remove(c("IHsurvrf_*.tar.gz", "src/*.o", "src/*.so", ...))
dyn.load("libRandoms.so")
# Load the Fortran library
dyn.load("libIHsurvrf.so")
result <- .survRF(
## selects subset of predictor matrix for eligible cases & ensures result is a matrix
x = x[elig,,drop=FALSE],
y = response[elig],
pr = pr,
delta = delta[elig],
params = params,
mTry = 5L,
txLevels = txLevels,
model = models,
sampleSize = 0.2)
source("SCRATCH_VerifyModels.R")
source("class_IH.Parameters.R")
source("IH.survRF.R")
# Load the C library
dyn.load("libRandoms.so")
# Load the Fortran library
dyn.load("libIHsurvrf.so")
library(methods)
## to use "Surv" for model
library(survival)
## simulate data for a single stage: "1"
dt <- data.frame("Y" = sample(1:100,100,TRUE),
"D" = rbinom(100, 1, 0.9),
"A" = rbinom(100, 1, 0.5),
"X" = rnorm(100))
## defined in VerifyTxName.R Script
# txName = A.1 (binary treatment 0 or 1)
# character
txName <- "A"
## create model
###### NOTE: use Verifymodels.R
models <-Surv(Y,D)~X+A
nDP <- 1
## defined in VerifyUsePrevTime.R script
usePrevTime <- F
stageLabel <- "."
# ensure that 'models' is provided as a formula or a list of formula and
# that the provided models can be generated by the data. If the input is
# appropriate, the object returned is list containing
#   "models" - the original input.
#   "response" - matrix of the survival response variables
## used in script VerifyModels.R
models <- .VerifyModels(models = models,
nDP = nDP,
data = dt,
txName = txName,
stageLabel = stageLabel,
usePrevTime = usePrevTime)
## extracts the "response variable": matrix of survival response variables
response <- models$response
## extracts the "delta" variable
del <- models$delta
## only including the models themselves & discarding "response" and "delta" components
models <- models$models
## create params
params <- .parameters(timePoints = "quad",
tau = NULL,
nTimes = 100L,
response = response,
nTree = 10L,
ERT = TRUE,
uniformSplit = NULL,
randomSplit = 0.2,
splitRule = NULL,
replace = NULL,
nodeSize = 6L,
minEvent = 3L,
tieMethod = "random",
criticalValue = "mean",
survivalTime = NULL,
nSamples = nSamples,
pooled = FALSE,
stratifiedSplit = NULL)
## ignoring prior step
## prepares model frame using the formula (input) and the data (input)
## missing values are not specifically handled (not omitted)
x <- stats::model.frame(formula = models, data = dt, na.action = na.pass)
# identify individuals with complete data
elig <- stats::complete.cases(x)
# extract response and delta from model frame
## extract survival response
response <- stats::model.response(data = x)
## extract censoring indicator (delta) from the second column of the "response" data
## "L" is used to indicate that 2 is an integer
delta <- response[,2L]
## updates the "response" variable to only include the first column of the original "response" data which represents survival times
response <- response[,1L]
## if first column of the model frame (x) is the response variable, remove this column
## probablhy to construct predicte response from the predictors, since the response has nothing to do with the prediction itself
if (attr(x = terms(x = models), which = "response") == 1L) {
x <- x[,-1L,drop = FALSE]
}
# identify time points <= response
tSurv <- sapply(X = response[elig],
# results in a logical integer (0 = FALSE)
FUN = function(s, tp) { as.integer(x = {s < tp}) },
tp = .TimePoints(object = params))
# time point nearest the response without going over
# {nTimes x nElig}
## pr: probability mass vector which binds transformed survival times (1, 0) (excluding first row) w values with a row of 1s
## for tSurv,each element is 1 if the survival time < corresponding time point. Otherwise, it's 0
## then subtract the transformed survival times to create a probability mass vector
## this calculates the difference between successive elements in each row of tSurv by translating binary indicators into p.survival until each time point
## there's now mass 1 at time point where each survival time is censored or an event, and 0 for all other time points
pr <- {rbind(tSurv[-1L,],1)-tSurv}
## extract levels of the factor treatment variable for eligible cases
txLevels <- levels(x = factor(x = dt[elig,txName]))
## running code:
result <- .survRF(
## selects subset of predictor matrix for eligible cases & ensures result is a matrix
x = x[elig,,drop=FALSE],
y = response[elig],
pr = pr,
delta = delta[elig],
params = params,
mTry = 5L,
txLevels = txLevels,
model = models,
sampleSize = 0.2)
source("IH.survRF.R")
result <- .survRF(
## selects subset of predictor matrix for eligible cases & ensures result is a matrix
x = x[elig,,drop=FALSE],
y = response[elig],
pr = pr,
delta = delta[elig],
params = params,
mTry = 5L,
txLevels = txLevels,
model = models,
sampleSize = 0.2)
source("IH.survRF.R")
result <- .survRF(
## selects subset of predictor matrix for eligible cases & ensures result is a matrix
x = x[elig,,drop=FALSE],
y = response[elig],
pr = pr,
delta = delta[elig],
params = params,
mTry = 5L,
txLevels = txLevels,
model = models,
sampleSize = 0.2)
library(IHsurvrf)
